# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _wavpy
else:
    import _wavpy

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class Waveform_complex_cluster(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_valid_wavs = property(_wavpy.Waveform_complex_cluster_num_valid_wavs_get, _wavpy.Waveform_complex_cluster_num_valid_wavs_set)
    num_phasor_iter = property(_wavpy.Waveform_complex_cluster_num_phasor_iter_get, _wavpy.Waveform_complex_cluster_num_phasor_iter_set)

    def __init__(self):
        _wavpy.Waveform_complex_cluster_swiginit(self, _wavpy.new_Waveform_complex_cluster())

    def initialize(self, in_cluster_length: "int", wav_in_length: "int") -> "void":
        return _wavpy.Waveform_complex_cluster_initialize(self, in_cluster_length, wav_in_length)

    def add_waveform(self, Icomp_in: "double *", Qcomp_in: "double *", cluster_pos: "int") -> "void":
        return _wavpy.Waveform_complex_cluster_add_waveform(self, Icomp_in, Qcomp_in, cluster_pos)

    def add_waveform_scale(self, Icomp_in: "double *", Qcomp_in: "double *", cluster_pos: "int", scale_factor: "double") -> "void":
        return _wavpy.Waveform_complex_cluster_add_waveform_scale(self, Icomp_in, Qcomp_in, cluster_pos, scale_factor)

    def add_waveform_GOLD(self, Icomponents_in: "signed char *", Qcomponents_in: "signed char *", cluster_pos: "int") -> "void":
        return _wavpy.Waveform_complex_cluster_add_waveform_GOLD(self, Icomponents_in, Qcomponents_in, cluster_pos)

    def add_waveform_PIR(self, XiYi: "short *", XqYq: "short *", XiYq: "short *", XqYi: "short *", cluster_pos: "int") -> "void":
        return _wavpy.Waveform_complex_cluster_add_waveform_PIR(self, XiYi, XqYq, XiYq, XqYi, cluster_pos)

    def load_ITF_waveforms_SPIR(self, namefile: "char const *", peak_delay_estimate: "double", BF_phases_UP: "double [8]", BF_phases_DW: "double [8]", filter_num: "int") -> "double":
        return _wavpy.Waveform_complex_cluster_load_ITF_waveforms_SPIR(self, namefile, peak_delay_estimate, BF_phases_UP, BF_phases_DW, filter_num)

    def integrate_waveforms(self, coherent_int: "int", wav_out: "double *") -> "void":
        return _wavpy.Waveform_complex_cluster_integrate_waveforms(self, coherent_int, wav_out)

    def integrate_waveforms_remdir(self, coherent_int: "int", coherent_int_dir: "int", wav_out: "double *") -> "void":
        return _wavpy.Waveform_complex_cluster_integrate_waveforms_remdir(self, coherent_int, coherent_int_dir, wav_out)

    def integrate_waveforms_retracking(self, coherent_int: "int", sampling_rate: "double", retracking_meters: "double *", wav_out: "double *") -> "void":
        return _wavpy.Waveform_complex_cluster_integrate_waveforms_retracking(self, coherent_int, sampling_rate, retracking_meters, wav_out)

    def dump_phase(self, lag_pos: "int") -> "void":
        return _wavpy.Waveform_complex_cluster_dump_phase(self, lag_pos)

    def dump_phase_peak(self) -> "void":
        return _wavpy.Waveform_complex_cluster_dump_phase_peak(self)

    def store_phasor_wavs(self, lag_pos: "int") -> "void":
        return _wavpy.Waveform_complex_cluster_store_phasor_wavs(self, lag_pos)

    def get_phasor(self, phasorI_out: "double *", phasorQ_out: "double *", valid_phasor_out: "signed char *") -> "void":
        return _wavpy.Waveform_complex_cluster_get_phasor(self, phasorI_out, phasorQ_out, valid_phasor_out)

    def get_sigma_phase_phasor(self, min_valid_samples: "int") -> "double":
        return _wavpy.Waveform_complex_cluster_get_sigma_phase_phasor(self, min_valid_samples)

    def get_sigma_phase_phasor_interv(self, init_sample: "int", interv_samples: "int", min_valid_samples: "int") -> "double":
        return _wavpy.Waveform_complex_cluster_get_sigma_phase_phasor_interv(self, init_sample, interv_samples, min_valid_samples)

    def counterrot_phasor(self, phases_rad: "double *", valid_phases: "signed char *") -> "void":
        return _wavpy.Waveform_complex_cluster_counterrot_phasor(self, phases_rad, valid_phases)

    def counterrot_waveforms(self, phases_rad: "double *", valid_phases: "signed char *") -> "void":
        return _wavpy.Waveform_complex_cluster_counterrot_waveforms(self, phases_rad, valid_phases)

    def correct_navigation_bit(self, lag_pos: "int", store_navbit_phasorI: "int") -> "void":
        return _wavpy.Waveform_complex_cluster_correct_navigation_bit(self, lag_pos, store_navbit_phasorI)

    def compute_coherence_time(self, lag_peak: "int", store_acf_phasorQ: "int") -> "double":
        return _wavpy.Waveform_complex_cluster_compute_coherence_time(self, lag_peak, store_acf_phasorQ)

    def compute_singlefreq_DDM(self, coherent_int: "int", doppler_freq: "double", freq_ddm: "double *") -> "void":
        return _wavpy.Waveform_complex_cluster_compute_singlefreq_DDM(self, coherent_int, doppler_freq, freq_ddm)

    def compute_singlefreq_DDM_remdir(self, coherent_int: "int", coherent_int_dir: "int", doppler_freq: "double", freq_ddm: "double *") -> "void":
        return _wavpy.Waveform_complex_cluster_compute_singlefreq_DDM_remdir(self, coherent_int, coherent_int_dir, doppler_freq, freq_ddm)

    def compute_singlelag_DDM(self, coherent_int: "int", lag_pos: "int", delta_freq: "double", lag_ddm: "double *") -> "void":
        return _wavpy.Waveform_complex_cluster_compute_singlelag_DDM(self, coherent_int, lag_pos, delta_freq, lag_ddm)

    def compute_singlelag_DDM_remdir(self, coherent_int: "int", coherent_int_dir: "int", lag_pos: "int", delta_freq: "double", lag_ddm: "double *") -> "void":
        return _wavpy.Waveform_complex_cluster_compute_singlelag_DDM_remdir(self, coherent_int, coherent_int_dir, lag_pos, delta_freq, lag_ddm)

    def compute_DopplerMap_BW(self, coherent_int: "int", lag_pos: "int", freq_samples: "int", delta_freq: "double") -> "double":
        return _wavpy.Waveform_complex_cluster_compute_DopplerMap_BW(self, coherent_int, lag_pos, freq_samples, delta_freq)

    def compute_DopplerMap_BW_remdir(self, coherent_int: "int", coherent_int_dir: "int", lag_pos: "int", freq_samples: "int", delta_freq: "double") -> "double":
        return _wavpy.Waveform_complex_cluster_compute_DopplerMap_BW_remdir(self, coherent_int, coherent_int_dir, lag_pos, freq_samples, delta_freq)

    def compute_whole_DDM(self, coherent_int: "int", ddm_delta_freq: "double", ddm: "double **", ddm_delay_samples: "int", ddm_freq_samples: "int") -> "void":
        return _wavpy.Waveform_complex_cluster_compute_whole_DDM(self, coherent_int, ddm_delta_freq, ddm, ddm_delay_samples, ddm_freq_samples)

    def compute_whole_DDM_remdir(self, coherent_int: "int", coherent_int_dir: "int", ddm_delta_freq: "double", ddm: "double **", ddm_delay_samples: "int", ddm_freq_samples: "int") -> "void":
        return _wavpy.Waveform_complex_cluster_compute_whole_DDM_remdir(self, coherent_int, coherent_int_dir, ddm_delta_freq, ddm, ddm_delay_samples, ddm_freq_samples)

    def compute_whole_DDM_retracking(self, coherent_int: "int", ddm_delta_freq: "double", ddm: "double **", ddm_delay_samples: "int", ddm_freq_samples: "int", sampling_rate: "double", retracking_meters: "double *") -> "void":
        return _wavpy.Waveform_complex_cluster_compute_whole_DDM_retracking(self, coherent_int, ddm_delta_freq, ddm, ddm_delay_samples, ddm_freq_samples, sampling_rate, retracking_meters)

    def compute_whole_LagHologram(self, powerLagHolo: "double **", lagHolo_lags: "int", lagHolo_freqs: "int") -> "void":
        return _wavpy.Waveform_complex_cluster_compute_whole_LagHologram(self, powerLagHolo, lagHolo_lags, lagHolo_freqs)

    def compute_LagHologram(self, lag: "int", powerLagHolo_singleLag: "double *") -> "void":
        return _wavpy.Waveform_complex_cluster_compute_LagHologram(self, lag, powerLagHolo_singleLag)

    def get_wav_length(self) -> "int":
        return _wavpy.Waveform_complex_cluster_get_wav_length(self)

    def get_cluster_length(self) -> "int":
        return _wavpy.Waveform_complex_cluster_get_cluster_length(self)
    __swig_destroy__ = _wavpy.delete_Waveform_complex_cluster

# Register Waveform_complex_cluster in _wavpy:
_wavpy.Waveform_complex_cluster_swigregister(Waveform_complex_cluster)


def integrate_wavs(coh_int: "int", coh_int_dir: "int", cl_length: "int", w_length: "int", freq: "double", valid: "bool *", Icomp: "double **", Qcomp: "double **", wav: "double *", retracking: "bool", retrack_samples: "double *") -> "void":
    return _wavpy.integrate_wavs(coh_int, coh_int_dir, cl_length, w_length, freq, valid, Icomp, Qcomp, wav, retracking, retrack_samples)

def integrate_wav_lag(coh_int: "int", coh_int_dir: "int", cl_length: "int", lag: "int", freq: "double", valid: "bool *", Icomp: "double **", Qcomp: "double **") -> "double":
    return _wavpy.integrate_wav_lag(coh_int, coh_int_dir, cl_length, lag, freq, valid, Icomp, Qcomp)

def compute_sigma_phase_phasor(init: "int", interval: "int", min_samples: "int", phasI: "double *", phasQ: "double *", valid: "bool *") -> "double":
    return _wavpy.compute_sigma_phase_phasor(init, interval, min_samples, phasI, phasQ, valid)

def check_SPIR_blocks(spirdata: "int *") -> "bool":
    return _wavpy.check_SPIR_blocks(spirdata)

def compute_RF_filter(filter: "float *") -> "void":
    return _wavpy.compute_RF_filter(filter)

def compute_RF_filter_GalileoE1(filter: "float *") -> "void":
    return _wavpy.compute_RF_filter_GalileoE1(filter)

def compute_RF_filter_GPS_L5(filter: "float *") -> "void":
    return _wavpy.compute_RF_filter_GPS_L5(filter)

def compute_ITFwav_SPIR(spirdata: "int *", interm_freq: "double", filter: "float *", wav_real: "double *", wav_imag: "double *", init_sample: "int", wav_size: "int", phases_UP: "double *", phases_DW: "double *", msec: "int") -> "void":
    return _wavpy.compute_ITFwav_SPIR(spirdata, interm_freq, filter, wav_real, wav_imag, init_sample, wav_size, phases_UP, phases_DW, msec)

def getSPIRdatabit(word: "int", pos: "int") -> "double":
    return _wavpy.getSPIRdatabit(word, pos)
class Waveform_power(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    positionMax = property(_wavpy.Waveform_power_positionMax_get, _wavpy.Waveform_power_positionMax_set)
    posSampleMax = property(_wavpy.Waveform_power_posSampleMax_get, _wavpy.Waveform_power_posSampleMax_set)
    sigma_posMax = property(_wavpy.Waveform_power_sigma_posMax_get, _wavpy.Waveform_power_sigma_posMax_set)
    powerMax = property(_wavpy.Waveform_power_powerMax_get, _wavpy.Waveform_power_powerMax_set)
    positionDer = property(_wavpy.Waveform_power_positionDer_get, _wavpy.Waveform_power_positionDer_set)
    posSampleDer = property(_wavpy.Waveform_power_posSampleDer_get, _wavpy.Waveform_power_posSampleDer_set)
    sigma_posDer = property(_wavpy.Waveform_power_sigma_posDer_get, _wavpy.Waveform_power_sigma_posDer_set)
    power_posDer = property(_wavpy.Waveform_power_power_posDer_get, _wavpy.Waveform_power_power_posDer_set)
    powerDer_posDer = property(_wavpy.Waveform_power_powerDer_posDer_get, _wavpy.Waveform_power_powerDer_posDer_set)
    floorNoise = property(_wavpy.Waveform_power_floorNoise_get, _wavpy.Waveform_power_floorNoise_set)
    positionRel = property(_wavpy.Waveform_power_positionRel_get, _wavpy.Waveform_power_positionRel_set)
    posSampleRel = property(_wavpy.Waveform_power_posSampleRel_get, _wavpy.Waveform_power_posSampleRel_set)
    sigma_posRel = property(_wavpy.Waveform_power_sigma_posRel_get, _wavpy.Waveform_power_sigma_posRel_set)
    slope_normTail = property(_wavpy.Waveform_power_slope_normTail_get, _wavpy.Waveform_power_slope_normTail_set)
    sigma_slope_normTail = property(_wavpy.Waveform_power_sigma_slope_normTail_get, _wavpy.Waveform_power_sigma_slope_normTail_set)

    def __init__(self):
        _wavpy.Waveform_power_swiginit(self, _wavpy.new_Waveform_power())

    def set_waveform(self, waveform_in: "double *") -> "void":
        return _wavpy.Waveform_power_set_waveform(self, waveform_in)

    def set_float_waveform(self, float_waveform_in: "float *") -> "void":
        return _wavpy.Waveform_power_set_float_waveform(self, float_waveform_in)

    def set_norm_waveform(self, norm_waveform_in: "float *", scale_factor_in: "double") -> "void":
        return _wavpy.Waveform_power_set_norm_waveform(self, norm_waveform_in, scale_factor_in)

    def get_waveform(self, waveform_out: "double *") -> "void":
        return _wavpy.Waveform_power_get_waveform(self, waveform_out)

    def add_waveform_retracking(self, waveform_in: "double *", retrack_delay: "double", wav_weight: "float", apply_safety_margin: "bool") -> "void":
        return _wavpy.Waveform_power_add_waveform_retracking(self, waveform_in, retrack_delay, wav_weight, apply_safety_margin)

    def set_sampling_rate(self, samplingRate: "double") -> "void":
        return _wavpy.Waveform_power_set_sampling_rate(self, samplingRate)

    def set_rel_factor(self, relFactor: "double") -> "void":
        return _wavpy.Waveform_power_set_rel_factor(self, relFactor)

    def get_rel_factor(self) -> "double":
        return _wavpy.Waveform_power_get_rel_factor(self)

    def set_min_resolution_fft_interp(self, resolution_in: "double") -> "void":
        return _wavpy.Waveform_power_set_min_resolution_fft_interp(self, resolution_in)

    def set_fit_length(self, fit_length_in: "double") -> "void":
        return _wavpy.Waveform_power_set_fit_length(self, fit_length_in)

    def set_normtail_length(self, normtail_length_in: "double") -> "void":
        return _wavpy.Waveform_power_set_normtail_length(self, normtail_length_in)

    def compute_delays(self) -> "void":
        return _wavpy.Waveform_power_compute_delays(self)

    def compute_delays_wspeckle(self, num_incoh: "int") -> "void":
        return _wavpy.Waveform_power_compute_delays_wspeckle(self, num_incoh)

    def compute_delays_wlimits(self, limits_center: "double", limits_width: "double", apriori_scattdel: "double") -> "void":
        return _wavpy.Waveform_power_compute_delays_wlimits(self, limits_center, limits_width, apriori_scattdel)

    def set_init_range(self, init_range_in: "double") -> "void":
        return _wavpy.Waveform_power_set_init_range(self, init_range_in)

    def get_range_waveform(self, range: "double *") -> "void":
        return _wavpy.Waveform_power_get_range_waveform(self, range)

    def dump_norm_waveform(self) -> "void":
        return _wavpy.Waveform_power_dump_norm_waveform(self)

    def dump_delays(self) -> "void":
        return _wavpy.Waveform_power_dump_delays(self)

    def get_wav_length(self) -> "int":
        return _wavpy.Waveform_power_get_wav_length(self)
    __swig_destroy__ = _wavpy.delete_Waveform_power

# Register Waveform_power in _wavpy:
_wavpy.Waveform_power_swigregister(Waveform_power)

class RF_FrontEnd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _wavpy.RF_FrontEnd_swiginit(self, _wavpy.new_RF_FrontEnd())

    def dump_parameters(self) -> "void":
        return _wavpy.RF_FrontEnd_dump_parameters(self)

    def set_antenna_orientation_BF_EH(self, antenna_vector_BF_E_in: "double [3]", antenna_vector_BF_H_in: "double [3]") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_orientation_BF_EH(self, antenna_vector_BF_E_in, antenna_vector_BF_H_in)

    def set_antenna_orientation_BF_k(self, antenna_vector_BF_k_in: "double [3]") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_orientation_BF_k(self, antenna_vector_BF_k_in)

    def get_antenna_orientation_BF(self) -> "void":
        return _wavpy.RF_FrontEnd_get_antenna_orientation_BF(self)

    def set_antenna_whole_pattern(self, antenna_whole_pattern_dB_in: "double [181][360]") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_whole_pattern(self, antenna_whole_pattern_dB_in)

    def set_val_antenna_pattern(self, phi_AntFrame: "int", theta_AntFrame: "int", pattern_dB_value: "double") -> "void":
        return _wavpy.RF_FrontEnd_set_val_antenna_pattern(self, phi_AntFrame, theta_AntFrame, pattern_dB_value)

    def set_antenna_pattern_FF(self, antenna_full_pattern_dB_in: "double [360]") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_pattern_FF(self, antenna_full_pattern_dB_in)

    def set_antenna_pattern_FH(self, antenna_half_pattern_dB_in: "double [181]") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_pattern_FH(self, antenna_half_pattern_dB_in)

    def set_antenna_pattern_interp(self, antenna_angles_deg: "double *", antenna_pattern_dB_in: "double *", min_level_dB: "double") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_pattern_interp(self, antenna_angles_deg, antenna_pattern_dB_in, min_level_dB)

    def set_antenna_patterns_FF(self, antenna_full_pattern_E_dB_in: "double [360]", antenna_full_pattern_H_dB_in: "double [360]") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_patterns_FF(self, antenna_full_pattern_E_dB_in, antenna_full_pattern_H_dB_in)

    def set_antenna_patterns_FH(self, antenna_half_pattern_E_dB_in: "double [181]", antenna_half_pattern_H_dB_in: "double [181]") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_patterns_FH(self, antenna_half_pattern_E_dB_in, antenna_half_pattern_H_dB_in)

    def set_antenna_patterns_interp(self, antenna_angles_E_deg: "double *", antenna_pattern_E_dB_in: "double *", antenna_angles_H_deg: "double *", antenna_pattern_H_dB_in: "double *", min_level_dB: "double") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_patterns_interp(self, antenna_angles_E_deg, antenna_pattern_E_dB_in, antenna_angles_H_deg, antenna_pattern_H_dB_in, min_level_dB)

    def get_antenna_whole_pattern(self) -> "void":
        return _wavpy.RF_FrontEnd_get_antenna_whole_pattern(self)

    def get_antenna_patterns(self) -> "void":
        return _wavpy.RF_FrontEnd_get_antenna_patterns(self)

    def set_receiver_params(self, antenna_Gain_dB_in: "double", antenna_T_in: "double", noise_F_dB_in: "double", filter_BB_BW_in: "double", isotropic_antenna: "signed char") -> "void":
        return _wavpy.RF_FrontEnd_set_receiver_params(self, antenna_Gain_dB_in, antenna_T_in, noise_F_dB_in, filter_BB_BW_in, isotropic_antenna)

    def set_antenna_eff_area(self, antenna_Aeff_in: "double") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_eff_area(self, antenna_Aeff_in)

    def set_noise_T(self, noise_T_in: "double") -> "void":
        return _wavpy.RF_FrontEnd_set_noise_T(self, noise_T_in)

    def set_noise_pow_dBW(self, noise_pow_dBW_in: "double") -> "void":
        return _wavpy.RF_FrontEnd_set_noise_pow_dBW(self, noise_pow_dBW_in)

    def get_anglesEH_gain_dB(self, angle_E_plane: "double", angle_H_plane: "double") -> "double":
        return _wavpy.RF_FrontEnd_get_anglesEH_gain_dB(self, angle_E_plane, angle_H_plane)

    def get_PhiTheta_gain_dB(self, phi_AntFrame: "double", theta_AntFrame: "double") -> "double":
        return _wavpy.RF_FrontEnd_get_PhiTheta_gain_dB(self, phi_AntFrame, theta_AntFrame)

    def get_incvector_gain_dB(self, incvector: "double [3]") -> "double":
        return _wavpy.RF_FrontEnd_get_incvector_gain_dB(self, incvector)

    def get_frequency(self) -> "double":
        return _wavpy.RF_FrontEnd_get_frequency(self)

    def get_antenna_Gain_dB(self) -> "double":
        return _wavpy.RF_FrontEnd_get_antenna_Gain_dB(self)

    def get_antenna_Aeff(self) -> "double":
        return _wavpy.RF_FrontEnd_get_antenna_Aeff(self)

    def get_antenna_T(self) -> "double":
        return _wavpy.RF_FrontEnd_get_antenna_T(self)

    def get_noise_T(self) -> "double":
        return _wavpy.RF_FrontEnd_get_noise_T(self)

    def get_noise_pow_dBW(self) -> "double":
        return _wavpy.RF_FrontEnd_get_noise_pow_dBW(self)

    def get_noise_F_dB(self) -> "double":
        return _wavpy.RF_FrontEnd_get_noise_F_dB(self)

    def get_filter_BB_BW(self) -> "double":
        return _wavpy.RF_FrontEnd_get_filter_BB_BW(self)

    def set_antenna_elements_pos_AF(self, element_pos_in: "double *", lambda_units: "char") -> "void":
        return _wavpy.RF_FrontEnd_set_antenna_elements_pos_AF(self, element_pos_in, lambda_units)

    def set_phase_delays(self, phase_delay_in: "double *") -> "void":
        return _wavpy.RF_FrontEnd_set_phase_delays(self, phase_delay_in)

    def get_phase_delays(self, phase_delay_out: "double *") -> "void":
        return _wavpy.RF_FrontEnd_get_phase_delays(self, phase_delay_out)

    def compute_array_factor(self) -> "void":
        return _wavpy.RF_FrontEnd_compute_array_factor(self)

    def get_array_factor(self) -> "void":
        return _wavpy.RF_FrontEnd_get_array_factor(self)

    def compute_phase_delays_UPA(self, theta_max: "double", phi_max: "double") -> "void":
        return _wavpy.RF_FrontEnd_compute_phase_delays_UPA(self, theta_max, phi_max)

    def compute_phase_delays_pos_ECEF_RT(self, inertials: "double [3]", posR_km: "double [3]", posT_km: "double [3]") -> "void":
        return _wavpy.RF_FrontEnd_compute_phase_delays_pos_ECEF_RT(self, inertials, posR_km, posT_km)
    __swig_destroy__ = _wavpy.delete_RF_FrontEnd

# Register RF_FrontEnd in _wavpy:
_wavpy.RF_FrontEnd_swigregister(RF_FrontEnd)


def Set_whole_pattern_from_EH_planes(ant_pattern_E_dB: "double [360]", ant_pattern_H_dB: "double [360]", ant_pattern_dB: "double [181][360]") -> "void":
    return _wavpy.Set_whole_pattern_from_EH_planes(ant_pattern_E_dB, ant_pattern_H_dB, ant_pattern_dB)

def Set_whole_pattern_from_EH_planes_RevLinInterp(ant_pattern_E_dB: "double [360]", ant_pattern_H_dB: "double [360]", ant_pattern_dB: "double [181][360]") -> "void":
    return _wavpy.Set_whole_pattern_from_EH_planes_RevLinInterp(ant_pattern_E_dB, ant_pattern_H_dB, ant_pattern_dB)

def Compute_PhiTheta_from_anglesEH(angleE: "double", angleH: "double", phi: "double *", theta: "double *") -> "void":
    return _wavpy.Compute_PhiTheta_from_anglesEH(angleE, angleH, phi, theta)

def Get_gain_pattern(theta: "double", phi: "double", ant_pattern_dB: "double [181][360]") -> "double":
    return _wavpy.Get_gain_pattern(theta, phi, ant_pattern_dB)

def Check_if_UPA_distribution(dimX: "int &", dimY: "int &", distX: "double &", distY: "double &", num: "int", positions: "double **") -> "bool":
    return _wavpy.Check_if_UPA_distribution(dimX, dimY, distX, distY, num, positions)
class GNSS_composite(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lambda_size = property(_wavpy.GNSS_composite_lambda_size_get, _wavpy.GNSS_composite_lambda_size_set)
    weight_CA = property(_wavpy.GNSS_composite_weight_CA_get, _wavpy.GNSS_composite_weight_CA_set)
    weight_PY = property(_wavpy.GNSS_composite_weight_PY_get, _wavpy.GNSS_composite_weight_PY_set)
    weight_M = property(_wavpy.GNSS_composite_weight_M_get, _wavpy.GNSS_composite_weight_M_set)
    weight_IM = property(_wavpy.GNSS_composite_weight_IM_get, _wavpy.GNSS_composite_weight_IM_set)
    weight_E1A = property(_wavpy.GNSS_composite_weight_E1A_get, _wavpy.GNSS_composite_weight_E1A_set)
    weight_E1B = property(_wavpy.GNSS_composite_weight_E1B_get, _wavpy.GNSS_composite_weight_E1B_set)
    weight_E1C = property(_wavpy.GNSS_composite_weight_E1C_get, _wavpy.GNSS_composite_weight_E1C_set)
    weight_B1I = property(_wavpy.GNSS_composite_weight_B1I_get, _wavpy.GNSS_composite_weight_B1I_set)
    weight_L1C = property(_wavpy.GNSS_composite_weight_L1C_get, _wavpy.GNSS_composite_weight_L1C_set)
    frequency = property(_wavpy.GNSS_composite_frequency_get, _wavpy.GNSS_composite_frequency_set)

    def __init__(self):
        _wavpy.GNSS_composite_swiginit(self, _wavpy.new_GNSS_composite())

    def dump_parameters(self) -> "void":
        return _wavpy.GNSS_composite_dump_parameters(self)

    def set_instrumental_params(self, input_sampling_rate: "double", input_filter_BW: "double", computeLambda: "char") -> "void":
        return _wavpy.GNSS_composite_set_instrumental_params(self, input_sampling_rate, input_filter_BW, computeLambda)

    def compute_lambda_func(self) -> "void":
        return _wavpy.GNSS_composite_compute_lambda_func(self)

    def get_lambda_func(self, range_vec: "double *", lambda_out: "double *") -> "void":
        return _wavpy.GNSS_composite_get_lambda_func(self, range_vec, lambda_out)
    __swig_destroy__ = _wavpy.delete_GNSS_composite

# Register GNSS_composite in _wavpy:
_wavpy.GNSS_composite_swigregister(GNSS_composite)

class Specular_geometry(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    longitudeS = property(_wavpy.Specular_geometry_longitudeS_get, _wavpy.Specular_geometry_longitudeS_set)
    latitudeS = property(_wavpy.Specular_geometry_latitudeS_get, _wavpy.Specular_geometry_latitudeS_set)
    elevation = property(_wavpy.Specular_geometry_elevation_get, _wavpy.Specular_geometry_elevation_set)
    azimuthR = property(_wavpy.Specular_geometry_azimuthR_get, _wavpy.Specular_geometry_azimuthR_set)
    azimuthT = property(_wavpy.Specular_geometry_azimuthT_get, _wavpy.Specular_geometry_azimuthT_set)
    geometric_delay = property(_wavpy.Specular_geometry_geometric_delay_get, _wavpy.Specular_geometry_geometric_delay_set)

    def __init__(self):
        _wavpy.Specular_geometry_swiginit(self, _wavpy.new_Specular_geometry())

    def dump_parameters(self) -> "void":
        return _wavpy.Specular_geometry_dump_parameters(self)

    def set_ECEFpos_Receiver(self, posR_in: "double [3]") -> "void":
        return _wavpy.Specular_geometry_set_ECEFpos_Receiver(self, posR_in)

    def get_ECEFpos_Receiver(self) -> "void":
        return _wavpy.Specular_geometry_get_ECEFpos_Receiver(self)

    def set_ECEFvel_Receiver(self, velR_in: "double [3]") -> "void":
        return _wavpy.Specular_geometry_set_ECEFvel_Receiver(self, velR_in)

    def get_ECEFvel_Receiver(self) -> "void":
        return _wavpy.Specular_geometry_get_ECEFvel_Receiver(self)

    def set_ECEFpos_Transmitter(self, posT_in: "double [3]") -> "void":
        return _wavpy.Specular_geometry_set_ECEFpos_Transmitter(self, posT_in)

    def get_ECEFpos_Transmitter(self) -> "void":
        return _wavpy.Specular_geometry_get_ECEFpos_Transmitter(self)

    def set_ECEFvel_Transmitter(self, velT_in: "double [3]") -> "void":
        return _wavpy.Specular_geometry_set_ECEFvel_Transmitter(self, velT_in)

    def get_ECEFvel_Transmitter(self) -> "void":
        return _wavpy.Specular_geometry_get_ECEFvel_Transmitter(self)

    def get_ECEFpos_Specular(self) -> "void":
        return _wavpy.Specular_geometry_get_ECEFpos_Specular(self)

    def set_LongLatHeight_Receiver(self, LonLatHeight_R_in: "double [3]") -> "void":
        return _wavpy.Specular_geometry_set_LongLatHeight_Receiver(self, LonLatHeight_R_in)

    def get_LongLatHeight_Receiver(self) -> "void":
        return _wavpy.Specular_geometry_get_LongLatHeight_Receiver(self)

    def set_LongLatHeight_Transmitter(self, LonLatHeight_T_in: "double [3]") -> "void":
        return _wavpy.Specular_geometry_set_LongLatHeight_Transmitter(self, LonLatHeight_T_in)

    def get_LongLatHeight_Transmitter(self) -> "void":
        return _wavpy.Specular_geometry_get_LongLatHeight_Transmitter(self)

    def set_geometry_from_ElevHeightsSpec(self, elev_in: "double", heightR_in: "double", heightT_in: "double", lonS_in: "double", latS_in: "double", azimT_in: "double", heightS_in: "double", computeUndu: "char") -> "void":
        return _wavpy.Specular_geometry_set_geometry_from_ElevHeightsSpec(self, elev_in, heightR_in, heightT_in, lonS_in, latS_in, azimT_in, heightS_in, computeUndu)

    def set_tangEarthVel_Receiver(self, velocity: "double", specAzim_deg: "double") -> "void":
        return _wavpy.Specular_geometry_set_tangEarthVel_Receiver(self, velocity, specAzim_deg)

    def set_tangEarthVel_Transmitter(self, velocity: "double", specAzim_deg: "double") -> "void":
        return _wavpy.Specular_geometry_set_tangEarthVel_Transmitter(self, velocity, specAzim_deg)

    def set_Undulation(self, undu: "double") -> "void":
        return _wavpy.Specular_geometry_set_Undulation(self, undu)

    def get_Undulation(self) -> "double":
        return _wavpy.Specular_geometry_get_Undulation(self)

    def read_ECEFpos_Receiver(self, namefile: "char const *", week: "int", sow: "double") -> "void":
        return _wavpy.Specular_geometry_read_ECEFpos_Receiver(self, namefile, week, sow)

    def read_ECEFpos_Transmitter(self, namefile: "char const *", week: "int", sow: "double") -> "void":
        return _wavpy.Specular_geometry_read_ECEFpos_Transmitter(self, namefile, week, sow)

    def read_ECEFpos_GNSS_Transmitter(self, namefile: "char const *", week: "int", sow: "double", prn: "int", gnss_identifier: "char") -> "void":
        return _wavpy.Specular_geometry_read_ECEFpos_GNSS_Transmitter(self, namefile, week, sow, prn, gnss_identifier)

    def compute_specular_point(self, computeUndu: "char") -> "void":
        return _wavpy.Specular_geometry_compute_specular_point(self, computeUndu)

    def compute_ElevAzimT_from_receiver(self) -> "void":
        return _wavpy.Specular_geometry_compute_ElevAzimT_from_receiver(self)

    def set_inertials(self, roll_in: "double", pitch_in: "double", heading_in: "double") -> "void":
        return _wavpy.Specular_geometry_set_inertials(self, roll_in, pitch_in, heading_in)

    def rotate_vector_BF_to_local(self, vector_BF_in: "double [3]") -> "void":
        return _wavpy.Specular_geometry_rotate_vector_BF_to_local(self, vector_BF_in)

    def rotate_vector_BF_to_ECEF(self, vector_BF_in: "double [3]") -> "void":
        return _wavpy.Specular_geometry_rotate_vector_BF_to_ECEF(self, vector_BF_in)

    def compute_inertial_delay(self, vector_BF_in: "double [3]") -> "double":
        return _wavpy.Specular_geometry_compute_inertial_delay(self, vector_BF_in)

    def read_Inertials_Receiver(self, namefile: "char const *", week: "int", sow: "double") -> "void":
        return _wavpy.Specular_geometry_read_Inertials_Receiver(self, namefile, week, sow)

    def compute_Beyerle_windup_direct(self, vector_r_a_BF: "double [3]", vector_r_t_BF: "double [3]", week: "int", sow: "double") -> "void":
        return _wavpy.Specular_geometry_compute_Beyerle_windup_direct(self, vector_r_a_BF, vector_r_t_BF, week, sow)

    def compute_Beyerle_windup_reflected(self, vector_r_a_BF: "double [3]", vector_r_t_BF: "double [3]", rvv: "double [2]", rhh: "double [2]", week: "int", sow: "double") -> "void":
        return _wavpy.Specular_geometry_compute_Beyerle_windup_reflected(self, vector_r_a_BF, vector_r_t_BF, rvv, rhh, week, sow)
    __swig_destroy__ = _wavpy.delete_Specular_geometry

# Register Specular_geometry in _wavpy:
_wavpy.Specular_geometry_swigregister(Specular_geometry)

class Reflecting_surface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    epsilon_real = property(_wavpy.Reflecting_surface_epsilon_real_get, _wavpy.Reflecting_surface_epsilon_real_set)
    epsilon_imag = property(_wavpy.Reflecting_surface_epsilon_imag_get, _wavpy.Reflecting_surface_epsilon_imag_set)
    mss_x = property(_wavpy.Reflecting_surface_mss_x_get, _wavpy.Reflecting_surface_mss_x_set)
    mss_y = property(_wavpy.Reflecting_surface_mss_y_get, _wavpy.Reflecting_surface_mss_y_set)
    sigma_z = property(_wavpy.Reflecting_surface_sigma_z_get, _wavpy.Reflecting_surface_sigma_z_set)
    c21_coeff = property(_wavpy.Reflecting_surface_c21_coeff_get, _wavpy.Reflecting_surface_c21_coeff_set)
    c03_coeff = property(_wavpy.Reflecting_surface_c03_coeff_get, _wavpy.Reflecting_surface_c03_coeff_set)
    wind_U10_speed = property(_wavpy.Reflecting_surface_wind_U10_speed_get, _wavpy.Reflecting_surface_wind_U10_speed_set)
    wind_U10_azimuth = property(_wavpy.Reflecting_surface_wind_U10_azimuth_get, _wavpy.Reflecting_surface_wind_U10_azimuth_set)
    medium = property(_wavpy.Reflecting_surface_medium_get, _wavpy.Reflecting_surface_medium_set)

    def __init__(self):
        _wavpy.Reflecting_surface_swiginit(self, _wavpy.new_Reflecting_surface())

    def dump_parameters(self) -> "void":
        return _wavpy.Reflecting_surface_dump_parameters(self)

    def set_frequency(self, frequency_GHz: "double") -> "void":
        return _wavpy.Reflecting_surface_set_frequency(self, frequency_GHz)

    def set_k_threshold(self, k_threshold_in: "double") -> "void":
        return _wavpy.Reflecting_surface_set_k_threshold(self, k_threshold_in)

    def set_k_threshold_Brown(self, incidence_deg: "double") -> "void":
        return _wavpy.Reflecting_surface_set_k_threshold_Brown(self, incidence_deg)

    def get_k_threshold(self) -> "double":
        return _wavpy.Reflecting_surface_get_k_threshold(self)

    def epsilon_sea_water(self, salinity: "double", temperature: "double") -> "void":
        return _wavpy.Reflecting_surface_epsilon_sea_water(self, salinity, temperature)

    def epsilon_sea_ice(self, brine_volume: "double") -> "void":
        return _wavpy.Reflecting_surface_epsilon_sea_ice(self, brine_volume)

    def epsilon_dry_snow(self, snow_density: "double") -> "void":
        return _wavpy.Reflecting_surface_epsilon_dry_snow(self, snow_density)

    def epsilon_wet_snow(self, snow_density: "double", water_volume: "double") -> "void":
        return _wavpy.Reflecting_surface_epsilon_wet_snow(self, snow_density, water_volume)

    def compute_Rfresnel_linear(self, incidence_deg: "double", epsilon_upLayer: "double [2]") -> "void":
        return _wavpy.Reflecting_surface_compute_Rfresnel_linear(self, incidence_deg, epsilon_upLayer)

    def compute_Rfresnel_circular(self, incidence_deg: "double", epsilon_upLayer: "double [2]") -> "void":
        return _wavpy.Reflecting_surface_compute_Rfresnel_circular(self, incidence_deg, epsilon_upLayer)

    def compute_Tfresnel_linear(self, incidence_deg: "double", epsilon_upLayer: "double [2]") -> "void":
        return _wavpy.Reflecting_surface_compute_Tfresnel_linear(self, incidence_deg, epsilon_upLayer)

    def compute_Tfresnel_circular(self, incidence_deg: "double", epsilon_upLayer: "double [2]") -> "void":
        return _wavpy.Reflecting_surface_compute_Tfresnel_circular(self, incidence_deg, epsilon_upLayer)

    def compute_sea_spectrum(self, num_samples: "int", delta_k_in: "double", theta_deg: "double", omega: "double") -> "void":
        return _wavpy.Reflecting_surface_compute_sea_spectrum(self, num_samples, delta_k_in, theta_deg, omega)

    def set_surf_spectrum(self, spectrum_in: "double *", kx_spec_in: "double *", ky_spec_in: "double *", delta_k_in: "double") -> "void":
        return _wavpy.Reflecting_surface_set_surf_spectrum(self, spectrum_in, kx_spec_in, ky_spec_in, delta_k_in)

    def set_surf_spectrum_omnidir(self, spectrum_in_omnidir: "double *", k_spec_in_omnidir: "double *", delta_k_in: "double") -> "void":
        return _wavpy.Reflecting_surface_set_surf_spectrum_omnidir(self, spectrum_in_omnidir, k_spec_in_omnidir, delta_k_in)

    def get_surf_spectrum(self, x: "int", y: "int") -> "void":
        return _wavpy.Reflecting_surface_get_surf_spectrum(self, x, y)

    def get_surf_spectrum_omnidir(self, x: "int") -> "void":
        return _wavpy.Reflecting_surface_get_surf_spectrum_omnidir(self, x)

    def compute_mss_from_spectrum(self) -> "void":
        return _wavpy.Reflecting_surface_compute_mss_from_spectrum(self)

    def compute_mss_from_wind(self) -> "void":
        return _wavpy.Reflecting_surface_compute_mss_from_wind(self)

    def set_wind_grid(self, wspeed_grid_in: "double *", wazim_grid_in: "double *", lon_in: "double *", lat_in: "double *") -> "void":
        return _wavpy.Reflecting_surface_set_wind_grid(self, wspeed_grid_in, wazim_grid_in, lon_in, lat_in)

    def interp_wind_grid(self, lon_in: "double", lat_in: "double") -> "void":
        return _wavpy.Reflecting_surface_interp_wind_grid(self, lon_in, lat_in)

    def disable_wind_grid(self) -> "void":
        return _wavpy.Reflecting_surface_disable_wind_grid(self)

    def get_wind_grid_status(self) -> "bool":
        return _wavpy.Reflecting_surface_get_wind_grid_status(self)
    __swig_destroy__ = _wavpy.delete_Reflecting_surface

# Register Reflecting_surface in _wavpy:
_wavpy.Reflecting_surface_swigregister(Reflecting_surface)

class ZaVoModel_GNSSR(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    polarization = property(_wavpy.ZaVoModel_GNSSR_polarization_get, _wavpy.ZaVoModel_GNSSR_polarization_set)
    exponent_wav_model_length = property(_wavpy.ZaVoModel_GNSSR_exponent_wav_model_length_get, _wavpy.ZaVoModel_GNSSR_exponent_wav_model_length_set)
    num_angles = property(_wavpy.ZaVoModel_GNSSR_num_angles_get, _wavpy.ZaVoModel_GNSSR_num_angles_set)
    wav_length = property(_wavpy.ZaVoModel_GNSSR_wav_length_get, _wavpy.ZaVoModel_GNSSR_wav_length_set)
    ddm_half_dopplers = property(_wavpy.ZaVoModel_GNSSR_ddm_half_dopplers_get, _wavpy.ZaVoModel_GNSSR_ddm_half_dopplers_set)
    sampling_rate = property(_wavpy.ZaVoModel_GNSSR_sampling_rate_get, _wavpy.ZaVoModel_GNSSR_sampling_rate_set)
    delta_doppler = property(_wavpy.ZaVoModel_GNSSR_delta_doppler_get, _wavpy.ZaVoModel_GNSSR_delta_doppler_set)
    delta_freq = property(_wavpy.ZaVoModel_GNSSR_delta_freq_get, _wavpy.ZaVoModel_GNSSR_delta_freq_set)
    coherent_integration = property(_wavpy.ZaVoModel_GNSSR_coherent_integration_get, _wavpy.ZaVoModel_GNSSR_coherent_integration_set)
    geometry = property(_wavpy.ZaVoModel_GNSSR_geometry_get, _wavpy.ZaVoModel_GNSSR_geometry_set)
    surface = property(_wavpy.ZaVoModel_GNSSR_surface_get, _wavpy.ZaVoModel_GNSSR_surface_set)
    receiver_Up = property(_wavpy.ZaVoModel_GNSSR_receiver_Up_get, _wavpy.ZaVoModel_GNSSR_receiver_Up_set)
    receiver_Down = property(_wavpy.ZaVoModel_GNSSR_receiver_Down_get, _wavpy.ZaVoModel_GNSSR_receiver_Down_set)
    gnss_signal = property(_wavpy.ZaVoModel_GNSSR_gnss_signal_get, _wavpy.ZaVoModel_GNSSR_gnss_signal_set)
    waveform_POW = property(_wavpy.ZaVoModel_GNSSR_waveform_POW_get, _wavpy.ZaVoModel_GNSSR_waveform_POW_set)

    def __init__(self):
        _wavpy.ZaVoModel_GNSSR_swiginit(self, _wavpy.new_ZaVoModel_GNSSR())

    def enable_isolines_data_dump(self, namefile: "char const *") -> "void":
        return _wavpy.ZaVoModel_GNSSR_enable_isolines_data_dump(self, namefile)

    def disable_isolines_data_dump(self) -> "void":
        return _wavpy.ZaVoModel_GNSSR_disable_isolines_data_dump(self)

    def compute_waveform(self, interferometric: "int", apply_curvature: "int", add_coherent_pow: "int", compute_wav_cov: "int", compute_ddm_cov: "int") -> "void":
        return _wavpy.ZaVoModel_GNSSR_compute_waveform(self, interferometric, apply_curvature, add_coherent_pow, compute_wav_cov, compute_ddm_cov)

    def get_DDM_doppler_slice(self, doppler_index: "int", dm_out: "double *") -> "void":
        return _wavpy.ZaVoModel_GNSSR_get_DDM_doppler_slice(self, doppler_index, dm_out)

    def get_cov_slice(self, cov_index: "int", cov_out: "double *") -> "void":
        return _wavpy.ZaVoModel_GNSSR_get_cov_slice(self, cov_index, cov_out)

    def get_noisy_waveform(self, wav_out: "double *", seed_in: "unsigned long") -> "void":
        return _wavpy.ZaVoModel_GNSSR_get_noisy_waveform(self, wav_out, seed_in)

    def get_noisy_DDM(self, ddm_row_out: "double *", seed_in: "unsigned long") -> "void":
        return _wavpy.ZaVoModel_GNSSR_get_noisy_DDM(self, ddm_row_out, seed_in)
    __swig_destroy__ = _wavpy.delete_ZaVoModel_GNSSR

# Register ZaVoModel_GNSSR in _wavpy:
_wavpy.ZaVoModel_GNSSR_swigregister(ZaVoModel_GNSSR)


def Compute_power_trans(signal: "GNSS_composite", elev: "double", atm_loss: "double", posTnorm: "double") -> "double":
    return _wavpy.Compute_power_trans(signal, elev, atm_loss, posTnorm)

def Doppler_func(k_scat: "double [3]", velR: "double [3]", k_inc: "double [3]", velT: "double [3]", frequency: "double") -> "double":
    return _wavpy.Doppler_func(k_scat, velR, k_inc, velT, frequency)

def Sigma0_func(surf: "Reflecting_surface", n_scat: "double [3]", n_inc: "double [3]", pol: "char", azimuthT: "double") -> "double":
    return _wavpy.Sigma0_func(surf, n_scat, n_inc, pol, azimuthT)

def PDFunction(surf: "Reflecting_surface", q: "double [3]", azimuthT: "double") -> "double":
    return _wavpy.PDFunction(surf, q, azimuthT)

def AntGain_EH_angles(ant_k: "double [3]", ant_E: "double [3]", ant_H: "double [3]", n_target_to_ant: "double [3]", out_angles: "double [2]") -> "void":
    return _wavpy.AntGain_EH_angles(ant_k, ant_E, ant_H, n_target_to_ant, out_angles)

def AntGain_PhiTheta_angles(ant_k: "double [3]", ant_E: "double [3]", ant_H: "double [3]", n_target_to_ant: "double [3]", out_angles: "double [2]") -> "void":
    return _wavpy.AntGain_PhiTheta_angles(ant_k, ant_E, ant_H, n_target_to_ant, out_angles)

def Compute_Covariance_DDM(power_direct_surf: "double", power_direct_rec: "double", sampling_rate: "double", coh_time: "double", BW: "double", pow_nd: "double", pow_nr: "double", delta_doppler: "double", power_surf: "double **", doppler_len: "int", delay_len: "int", lambda_func: "double *", lambda_len: "int", wav_out: "double *", ddm_out: "double **", cov_out: "double **", chol_out: "double **", wav_len: "int", interferometric: "int", ddm_freq_factor: "int", compute_ddm: "bool") -> "void":
    return _wavpy.Compute_Covariance_DDM(power_direct_surf, power_direct_rec, sampling_rate, coh_time, BW, pow_nd, pow_nr, delta_doppler, power_surf, doppler_len, delay_len, lambda_func, lambda_len, wav_out, ddm_out, cov_out, chol_out, wav_len, interferometric, ddm_freq_factor, compute_ddm)

def Get_noise_string(out_string: "double *", mean_string: "double *", len_string: "int", chol_mat: "double **", seed_rn: "int") -> "void":
    return _wavpy.Get_noise_string(out_string, mean_string, len_string, chol_mat, seed_rn)
class MRSR_Model(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    receiver = property(_wavpy.MRSR_Model_receiver_get, _wavpy.MRSR_Model_receiver_set)
    gnss_signal = property(_wavpy.MRSR_Model_gnss_signal_get, _wavpy.MRSR_Model_gnss_signal_set)
    waveforms = property(_wavpy.MRSR_Model_waveforms_get, _wavpy.MRSR_Model_waveforms_set)

    def __init__(self):
        _wavpy.MRSR_Model_swiginit(self, _wavpy.new_MRSR_Model())

    def set_general_scenario(self, height_in: "double", depths_in: "double *", alpha_x_in: "double *", alpha_y_in: "double *", epsilon_r_in: "double *", epsilon_i_in: "double *") -> "void":
        return _wavpy.MRSR_Model_set_general_scenario(self, height_in, depths_in, alpha_x_in, alpha_y_in, epsilon_r_in, epsilon_i_in)

    def set_planar_layers_scenario(self, height_in: "double", depths_in: "double *", epsilon_r_in: "double *", epsilon_i_in: "double *") -> "void":
        return _wavpy.MRSR_Model_set_planar_layers_scenario(self, height_in, depths_in, epsilon_r_in, epsilon_i_in)

    def set_dry_snow_planar_layers_scenario(self, height_in: "double", depths_in: "double *", snow_dens_in: "double *") -> "void":
        return _wavpy.MRSR_Model_set_dry_snow_planar_layers_scenario(self, height_in, depths_in, snow_dens_in)

    def mod_height_depths(self, height_in: "double", depths_in: "double *") -> "void":
        return _wavpy.MRSR_Model_mod_height_depths(self, height_in, depths_in)

    def mod_alphas(self, alpha_x_in: "double *", alpha_y_in: "double *") -> "void":
        return _wavpy.MRSR_Model_mod_alphas(self, alpha_x_in, alpha_y_in)

    def mod_epsilon(self, epsilon_r_in: "double *", epsilon_i_in: "double *") -> "void":
        return _wavpy.MRSR_Model_mod_epsilon(self, epsilon_r_in, epsilon_i_in)

    def compute_GNSS_wavcluster(self, wav_lags: "int", lag_direct_pos: "int", sampling_rate: "double", elevations: "double *", yaws: "double *") -> "void":
        return _wavpy.MRSR_Model_compute_GNSS_wavcluster(self, wav_lags, lag_direct_pos, sampling_rate, elevations, yaws)

    def compute_LH_freqs_and_depths(self, elev_range: "double [2]", azim_range: "double [2]", time_range: "double [2]", freq_LH: "double *", depth_LH: "double *") -> "void":
        return _wavpy.MRSR_Model_compute_LH_freqs_and_depths(self, elev_range, azim_range, time_range, freq_LH, depth_LH)

    def compute_pow_linearPol(self, elevation: "double", yaw: "double", freq: "double") -> "void":
        return _wavpy.MRSR_Model_compute_pow_linearPol(self, elevation, yaw, freq)
    __swig_destroy__ = _wavpy.delete_MRSR_Model

# Register MRSR_Model in _wavpy:
_wavpy.MRSR_Model_swigregister(MRSR_Model)


def compute_elevs_out(elev_in: "double", elevs_out: "double *", valid_elevs_out: "bool *", depth_layer: "double *", alpha_plane: "double *", epsilon_r: "double *", epsilon_i: "double *", num_layers: "int") -> "int":
    return _wavpy.compute_elevs_out(elev_in, elevs_out, valid_elevs_out, depth_layer, alpha_plane, epsilon_r, epsilon_i, num_layers)

def theta_layer2_Snell(theta_layer1: "double", eps_r_layer1: "double", eps_i_layer1: "double", eps_r_layer2: "double", eps_i_layer2: "double") -> "double":
    return _wavpy.theta_layer2_Snell(theta_layer1, eps_r_layer1, eps_i_layer1, eps_r_layer2, eps_i_layer2)

def get_layered_powrange(elev_in: "double", height_rec: "double", _lambda: "double", depth_layer: "double *", alpha_plane: "double *", epsilon_r: "double *", epsilon_i: "double *", elevs_out: "double *", valid_elevs_out: "bool *", num_layers: "int", range_out: "double *", amp_pol1: "double *", amp_pol2: "double *", lin_pol: "bool") -> "int":
    return _wavpy.get_layered_powrange(elev_in, height_rec, _lambda, depth_layer, alpha_plane, epsilon_r, epsilon_i, elevs_out, valid_elevs_out, num_layers, range_out, amp_pol1, amp_pol2, lin_pol)

def traverse_single_layer(theta_normal: "double", orig_thickness: "double", alpha_layer: "double", alpha_beneath_layer: "double", epsilon_r: "double", epsilon_i: "double", _lambda: "double", up2down: "bool", horizontal_pos: "double &", delta_range: "double &", amp_atten: "double &") -> "bool":
    return _wavpy.traverse_single_layer(theta_normal, orig_thickness, alpha_layer, alpha_beneath_layer, epsilon_r, epsilon_i, _lambda, up2down, horizontal_pos, delta_range, amp_atten)


